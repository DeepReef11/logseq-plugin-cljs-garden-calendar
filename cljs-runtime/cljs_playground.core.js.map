{"version":3,"sources":["cljs_playground/core.cljs"],"mappings":";;AAuHA,8CAAA,9CAAMA;AAAN,AACEC;;AAEF,AAAKC,0BAAG,kDAAA,AAAA,lDAACC;AACT,AAACC,yGAAQ,yBAAA,xBAAMF;AAEf,qCAAA,rCAAMG;AAAN,AACE,AAAKC,mCAAYC;;AACjB,IAAAC,WAAA;IAAAC,WAAA;AAAA,AAEE,gHAAA,zGAACL;;AAFH,AAAA,wIAAAI,SAAAC,uDAAAD,SAAAC,zMAACH,iEAAAA,oFAAAA;;AAMH,4BAAA,5BAAMI;AAAN,AACE,mBAAA,nBAACC;;AACD,OAACN;;AAIH,4BAAA,5BAAMO;AAAN,OACM,AAACC,aAAgBH,pBACjB,qDAAQI","names":["cljs-playground.core/create-garden-calendar","js/logseq.Editor.","cljs-playground.core/x1","cljs.core.int_array","cljs.core.println","cljs-playground.core/slashcommands","cljs-playground.core/regSlashCmd","js/logseq.Editor.registerSlashCommand","G__29479","G__29480","cljs-playground.core/main","js/logseq.App.showMsg","cljs-playground.core/init","js/logseq.ready","js/console.error"],"sourcesContent":[";; (ns cljs-playground.core\n;;   (:require \n;;    [applied-science.js-interop :as j]\n;;    [cljs-http.client :as http]\n;;    [datascript.core :as d]\n;;    [com.wsscode.async.async-cljs :as wa :refer [go-promise  <? <?maybe]]\n;;   ))\n\n;; (defonce db\n;;   (d/create-conn\n;;    {:things.area/uuid {:db/unique :db.unique/identity}\n;;     :things.task/uuid {:db/unique :db.unique/identity}\n;;     :things.checklist/uuid  {:db/unique :db.unique/identity}\n;;     :things.task/area {:db/valueType :db.type/ref}\n;;     :things.task/project {:db/valueType :db.type/ref}\n;;     :things.checklist/task {:db/valueType :db.type/ref}}))\n\n;; (def debug (partial println \"debug:\"))\n;; (defn go-get-data-from-proxy []\n;;   (go-promise (:body (<? (http/get \"http://localhost:7980\")))))\n\n\n;; (defn go-load-db! []\n;;   (go-promise (d/transact! db (<? (go-get-data-from-proxy)))\n;;               (debug (str \"Datum count \" (count (:eavt @db))))))\n\n\n\n;; ;(def trace (partial println \"trace:\"))\n;; (def trace (constantly nil))\n;; ; for now reloads data from things db proxy\n;; ; before running the command. Intended to wrap top\n;; ; level commands to ensure data is current\n;; ; could potentially skip reload if data was recently loaded\n;; ; or ideally implement subscription for real time updates\n;; (defn with-things-db [f]\n;;   (fn [& args]\n;;     (go-promise (<?maybe (go-load-db!))\n;;                 (<?maybe (apply f args)))))\n\n\n\n;; (js/logseq.App.showMsg \"Hello from Clojure!\")\n\n\n;; (defn logseq* [obj method & args]\n;;   (let [jsargs (mapv clj->js args)\n;;         v (j/get obj method)\n;;         ;_ (trace (str (cons method jsargs)))\n;;         _ (trace (pr-str (cons method args)))\n;;         result (if-not (ifn? v) v\n;;                        (apply (partial j/call obj method) jsargs))]\n\n;;     (if (instance? js/Promise result)\n;;       (go-promise\n;;        (let [result (wa/<?maybe result)\n;;              ;_ (trace method \">>\" result) \n;;              result (js->clj result :keywordize-keys true)]\n;;          (trace method \">\" result)\n;;          result))\n;;       (let [;_ (trace method \">>\" result) \n;;             result (js->clj result :keywordize-keys true)]\n;;         (trace method \">\" result)\n;;         result))))\n;; (def last-error (volatile! nil))\n;; (def show-msg! (partial logseq* js/logseq.App :showMsg))\n;; (defn displaying-errors [f]\n;;   (fn [& args]\n;;     (go-promise\n;;      (<?maybe (try (<?maybe (apply f args))\n;;                    (catch :default e\n;;                      (debug \"Caught Error: \" e)\n;;                      (j/call js/console :error e)\n;;                      (vreset! last-error e)\n;;                      (show-msg! (str \"Error:\\n\"\n;;                                      (pr-str e)))))))))\n\n;; (def register-command*! (partial logseq* js/logseq.App :registerCommand))\n;; (defn with-promise-result [f]\n;;   (fn [& args]\n;;     (new js/Promise\n;;          (fn [resolve reject]\n;;            (go-promise (try (resolve (<?maybe (apply f args)))\n;;                             (catch :default e (reject e))))))))\n\n;; (def register-command-palette*! (partial logseq* js/logseq.App :registerCommandPalette))\n;; (defn register-command-palette! [opts callback]\n;;   (register-command-palette*! opts (with-promise-result (displaying-errors callback))))\n\n;; (defn main []\n;;   (js/logseq.App.showMsg \"Hello from Clojure!\")\n;;   (register-command-palette! {:key \"insert-calendar\" :label \"Insert gardening calendar\"}\n;;                              (with-things-db println)\n;; ))\n\n;; (defn callbacktest []\n;;   (println \"callback working\"))\n\n;; (js/logseq.App.showMsg \"Hello from Clojure!\")\n;; (register-command-palette! {:key \"insert-calendar\" :label \"Insert gardening calendar\"}\n;;                              (with-things-db callbacktest)\n;;                              )\n\n;; (defn init []\n;;   (-> (js/logseq.ready main)\n;;       (.catch js/console.error)))\n\n\n(ns cljs-playground.core\n  (:require \n    [\"@logseq/libs\"]\n   [applied-science.js-interop :as j]\n   [cljs-http.client :as http]\n   [datascript.core :as d]\n   [com.wsscode.async.async-cljs :as wa :refer [go-promise  <? <?maybe]]\n  ))\n\n\n\n(defn create-garden-calendar []\n  js/logseq.Editor.\n  )\n(def x1 (int-array '(1 2 3)))\n(println (aget x1 2))\n\n(defn slashcommands []\n  (def regSlashCmd js/logseq.Editor.registerSlashCommand)\n  (regSlashCmd\n   \"create-garden-calendar\"\n   #(println \"ok2\")))\n  \n\n\n(defn main []\n  (js/logseq.App.showMsg \"Gardening rocks!\")\n  (slashcommands)\n)  \n   \n\n(defn init []\n  (-> (js/logseq.ready main)\n      (.catch js/console.error)))\n\n\n\n"]}
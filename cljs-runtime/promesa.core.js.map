{"version":3,"sources":["promesa/core.cljc"],"mappings":"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","names":["promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/deferred","promesa.impl/deferred","var_args","G__48839","promesa.core/promise","js/Error","promesa.protocols/-promise","executor","promesa.protocols/-fmap","cljs.core/identity","promesa.core/wrap","G__48847","promesa.core/create","f","d","e48850","G__48851","p1__48840#","G__48852","p1__48841#","promesa.protocols/-resolve!","promesa.protocols/-reject!","e","promesa.exec.run_BANG_","e48856","G__48858","p1__48842#","G__48859","p1__48843#","promesa.core/promise?","promesa.impl/promise?","promesa.core/deferred?","promesa.impl/deferred?","promesa.core/thenable?","cljs.core/object?","cljs.core/fn?","promesa.core/resolved?","p","promesa.protocols/-resolved?","promesa.core/rejected?","promesa.protocols/-rejected?","promesa.core/pending?","promesa.protocols/-pending?","G__48868","promesa.core/extract","promesa.protocols/-extract","default","promesa.core/done?","cljs.core/not","G__48875","promesa.core/then","promesa.protocols/-then","G__48877","promesa.core/then'","G__48887","promesa.core/bind","promesa.protocols/-mcat","G__48889","promesa.core/map","G__48899","promesa.core/fmap","G__48901","promesa.core/mapcat","G__48910","promesa.core/mcat","G__48920","promesa.core/chain","args-arr__4885__auto__","len__4864__auto__","i__4865__auto__","argseq__4886__auto__","cljs.core/IndexedSeq","seq48917","G__48918","cljs.core/first","cljs.core/next","G__48919","self__4851__auto__","promesa.core.then","fs","cljs.core.reduce","cljs.core/cons","G__48929","promesa.core/chain'","seq48926","G__48927","G__48928","promesa.core.then_SINGLEQUOTE_","p1__48924#","p2__48923#","promesa.core.map","G__48932","promesa.core/handle","promesa.protocols/-hmap","cljs.core.comp","G__48941","promesa.core/finally","promesa.protocols/-fnly","G__48949","promesa.core/hmap","G__48957","promesa.core/hcat","G__48967","promesa.core/fnly","G__48975","promesa.core/catch","p1__48969#","promesa.protocols/-merr","pred-or-type","accept?","p1__48970#","cljs.core/ifn?","G__48979","promesa.core/merr","promesa.core/all","promises","promesa.impl/all","promesa.core/race","promesa.impl/race","G__48986","promesa.core/any","promesa.core.any","items","cljs.core.into","state","cljs.core/volatile!","lock","promesa.util/mutex","promesa.core.create","resolve","reject","seq__48989","cljs.core/seq","chunk__48991","count__48992","i__48993","temp__5753__auto__","cljs.core/chunked-seq?","c__4679__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","exception","cljs.core/deref","cljs.core.update","cljs.core/disj","cljs.core/conj","cljs.core._EQ_","G__49016","G__49018","cljs.core.ex_info","map__49017","cljs.core/--destructure-map","cljs.core.get","map__49019","pending","cljs.core.assoc","promesa.core/wait-all*","cljs.core/set","total","prom","counter","cljs.core.atom","p1__49020#","cljs.core/run!","_","cljs.core.swap_BANG_","cljs.core/dec","args__4870__auto__","argseq__4871__auto__","promesa.core/wait-all","seq49021","self__4852__auto__","G__49032","promesa.core/run!","coll","p1__49023#","p2__49024#","cljs.core/constantly","p1__49025#","p2__49026#","promesa.core/cancel!","promesa.protocols/-cancel!","promesa.core/cancelled?","promesa.protocols/-cancelled?","G__49040","promesa.core/resolve!","o","promesa.core/reject!","promesa.core/promisify","callable","args","cljs.core/vec","cljs.core.conj","e49050","cljs.core.apply","promesa.core/TimeoutException","message","it","goog/inherits","G__49057","promesa.core/timeout","t","promesa.core.timeout","scheduler","timeout","tid","promesa.exec.schedule_BANG_","promesa.core.resolve_BANG_","promesa.core.fnly","G__49064","promesa.core/delay","promesa.core.delay","G__49085","promesa.core/thread-call","promesa.exec.submit_BANG_","promesa.exec/wrap-bindings","promesa.core/vthread-call","promesa.core.thread_call","this__4502__auto__","k__4503__auto__","this__4504__auto__","k49091","else__4505__auto__","G__49098","cljs.core/Keyword","bindings","__extmap","this__4522__auto__","f__4523__auto__","init__4524__auto__","ret__4525__auto__","p__49100","vec__49102","k__4526__auto__","cljs.core.nth","v__4527__auto__","this__4517__auto__","writer__4518__auto__","opts__4519__auto__","pr-pair__4520__auto__","keyval__4521__auto__","cljs.core/pr-sequential-writer","cljs.core.concat","cljs.core/PersistentVector","G__49090","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__4500__auto__","__meta","this__4497__auto__","__hash","this__4506__auto__","this__4498__auto__","h__4360__auto__","coll__4499__auto__","cljs.core/hash-unordered-coll","this49092","other49093","this__4512__auto__","k__4513__auto__","cljs.core/contains?","cljs.core.dissoc","cljs.core/-with-meta","cljs.core/not-empty","this__4509__auto__","G__49113","this__4510__auto__","k__4511__auto__","pred__49115","cljs.core/keyword-identical?","expr__49116","this__4515__auto__","cljs.core/MapEntry","this__4501__auto__","this__4507__auto__","entry__4508__auto__","cljs.core/vector?","cljs.core/-nth","cljs.core/-conj","promesa.core/Recur","this__4546__auto__","cljs.core/List","writer__4547__auto__","cljs.core/-write","G__49095","extmap__4542__auto__","G__49126","cljs.core/record?","promesa.core/->Recur","promesa.core/map->Recur","promesa.core/recur?"],"sourcesContent":[";; This Source Code Form is subject to the terms of the Mozilla Public\n;; License, v. 2.0. If a copy of the MPL was not distributed with this\n;; file, You can obtain one at http://mozilla.org/MPL/2.0/.\n;;\n;; Copyright (c) Andrey Antukh <niwi@niwi.nz>\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise\n                            await map mapcat run!\n                            future let loop recur\n                            -> ->> as-> with-redefs do\n                            doseq])\n  (:require\n   [promesa.protocols :as pt]\n   [clojure.core :as c]\n   [promesa.exec :as exec]\n   [promesa.impl :as impl]\n   [promesa.util :as util])\n  #?(:cljs (:require-macros [promesa.core]))\n  #?(:clj\n     (:import\n      java.util.concurrent.CompletableFuture\n      java.util.concurrent.CompletionException\n      java.util.concurrent.CompletionStage\n      java.util.concurrent.ExecutionException\n      java.util.concurrent.TimeoutException)))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn deferred\n  \"Creates an empty promise instance.\"\n  []\n  (impl/deferred))\n\n(defn promise\n  \"The coerce based promise constructor. Creates an appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.\"\n  ([v]\n   (pt/-promise v))\n  ([v executor]\n   (pt/-fmap (pt/-promise v) identity executor)))\n\n(defn wrap\n  \"A convenience alias for `promise` coercion function that only accepts\n  a single argument.\"\n  [v]\n  (pt/-promise v))\n\n(defn create\n  \"Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.\"\n  ([f]\n   (c/let [d (impl/deferred)]\n     (try\n       (f #(pt/-resolve! d %)\n          #(pt/-reject! d %))\n       (catch #?(:clj Throwable :cljs :default) e\n         (pt/-reject! d e)))\n     d))\n  ([f executor]\n   (c/let [d (impl/deferred)]\n     (exec/run! executor (fn []\n                           (try\n                             (f #(pt/-resolve! d %)\n                                #(pt/-reject! d %))\n                             (catch #?(:clj Exception :cljs :default) e\n                               (pt/-reject! d e)))))\n     d)))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  (impl/promise? v))\n\n(defn deferred?\n  \"Return true if `v` is a deferred instance.\"\n  [v]\n  (impl/deferred? v))\n\n#?(:cljs\n   (defn thenable?\n     \"Returns true if `v` is a promise like object.\"\n     [v]\n     (and (object? v) (fn? (unchecked-get v \"then\")))))\n\n;; Predicates\n\n(defn resolved?\n  \"Returns true if promise `p` is already fulfilled.\"\n  [p]\n  (pt/-resolved? p))\n\n(defn rejected?\n  \"Returns true if promise `p` is already rejected.\"\n  [p]\n  (pt/-rejected? p))\n\n(defn pending?\n  \"Returns true if promise `p` is stil pending.\"\n  [p]\n  (pt/-pending? p))\n\n(defn extract\n  \"Returns the current promise value.\"\n  ([p]\n   (pt/-extract p))\n  ([p default]\n   (pt/-extract p default)))\n\n(defn done?\n  \"Returns true if promise `p` is already done.\"\n  [p]\n  (not (pt/-pending? p)))\n\n;; Chaining\n\n(defn then\n  \"Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument; `f`\n  can return a plain value or promise instance, an automatic\n  unwrapping will be performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\"\n  ([p f]\n   (pt/-then (pt/-promise p) f))\n  ([p f executor]\n   (pt/-then (pt/-promise p) f executor)))\n\n(defn then'\n  \"Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument; `f`\n  should return a plain value, no automatic unwrapping will be\n  performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\"\n  ([p f]\n   (pt/-fmap (pt/-promise p) f))\n  ([p f executor]\n   (pt/-fmap (pt/-promise p) f executor)))\n\n(defn bind\n  \"Chains a function `f` to be executed with when the promise `p` is\n  successfully resolved. Returns a promise that will mirror the\n  promise instance returned by calling `f` with the value as single\n  argument; `f` **must** return a promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\"\n  ([p f]\n   (pt/-mcat (pt/-promise p) f))\n  ([p f executor]\n   (pt/-mcat (pt/-promise p) f executor)))\n\n(defn map\n  \"Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will be resolved with\n  the return value of calling `f` with value as single argument.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This function is intended to be used with `->>`.\"\n  ([f p]\n   (pt/-fmap (pt/-promise p) f))\n  ([executor f p]\n   (pt/-fmap (pt/-promise p) f executor)))\n\n(defn fmap\n  \"A convenience alias for `map`.\"\n  ([f p]\n   (pt/-fmap (pt/-promise p) f))\n  ([executor f p]\n   (pt/-fmap (pt/-promise p) f executor)))\n\n(defn mapcat\n  \"Chains a function `f` to be executed when the promise `p` is\n  successfully resolved. Returns a promise that will mirror the\n  promise instance returned by calling `f` with the value as single\n  argument; `f` **must** return a promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This funciton is intended to be used with `->>`.\"\n  ([f p]\n   (pt/-mcat (pt/-promise p) f))\n  ([executor f p]\n   (pt/-mcat (pt/-promise p) f executor)))\n\n(defn mcat\n  \"A convenience alias for `mapcat`.\"\n  ([f p]\n   (pt/-mcat (pt/-promise p) f))\n  ([executor f p]\n   (pt/-mcat (pt/-promise p) f executor)))\n\n(defn chain\n  \"Chain variable number of functions to be executed serially using\n  `then`.\"\n  ([p f] (then p f))\n  ([p f & fs] (reduce then p (cons f fs))))\n\n(defn chain'\n  \"Chain variable number of functions to be executed serially using\n  `map`.\"\n  ([p f] (then' p f))\n  ([p f & fs] (reduce #(map %2 %1) (pt/-promise p) (cons f fs))))\n\n(defn handle\n  \"Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise completed (resolving or\n  rejecting) with the return value of calling `f` with both: value and\n  the exception; `f` can return a new plain value or promise instance,\n  and automatic unwrapping will be performed.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  For performance sensitive code, look at `hmap` and `hcat`.\"\n  ([p f]\n   #?(:cljs (c/-> (pt/-promise p)\n                  (pt/-hmap (comp pt/-promise f))\n                  (pt/-mcat identity))\n      :clj  (c/-> (pt/-promise p)\n                  (pt/-hmap (comp pt/-promise f))\n                  (util/unwrap-completion-stage))))\n  ([p f executor]\n   #?(:cljs (c/-> (pt/-promise p)\n                  (pt/-hmap (comp pt/-promise f) executor)\n                  (pt/-mcat identity executor))\n      :clj  (c/-> (pt/-promise p)\n                  (pt/-hmap (comp pt/-promise f) executor)\n                  (util/unwrap-completion-stage)))))\n\n(defn finally\n  \"Like `handle` but ignores the return value. Returns a promise that\n  will mirror the original one.\"\n  ([p f]\n   (c/-> (pt/-promise p)\n         (pt/-fnly f)))\n  ([p f executor]\n   (c/-> (pt/-promise p)\n         (pt/-fnly f executor))))\n\n(defn hmap\n  \"Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise completed (resolving or\n  rejecting) with the return value of calling `f` with both: value and\n  the exception.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  Intended to be used with `->>`.\"\n  ([f p]\n   (pt/-hmap (pt/-promise p) f))\n  ([executor f p]\n   (pt/-hmap (pt/-promise p) f executor)))\n\n(defn hcat\n  \"Chains a function `f` to be executed when the promise `p` is completed\n  (resolved or rejected) and returns a promise that will mirror the\n  promise instance returned by calling `f` with both: value and the\n  exception. The `f` function must return a promise instance.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  Intended to be used with `->>`.\"\n  ([f p]\n   #?(:cljs (c/-> (pt/-promise p)\n                  (pt/-hmap f)\n                  (pt/-mcat identity))\n      :clj  (c/-> (pt/-promise p)\n                  (pt/-hmap f)\n                  (util/unwrap-completion-stage))))\n  ([executor f p]\n   #?(:cljs (c/-> (pt/-promise p)\n                  (pt/-hmap f executor)\n                  (pt/-mcat identity executor))\n      :clj  (c/-> (pt/-promise p)\n                  (pt/-hmap f executor)\n                  (util/unwrap-completion-stage)))))\n\n(defn fnly\n  \"Inverted arguments version of `finally`; intended to be used with\n  `->>`.\"\n  ([f p]\n   (pt/-fnly (pt/-promise p) f))\n  ([executor f p]\n   (pt/-fnly (pt/-promise p) f executor)))\n\n(defn catch\n  \"Chains a function `f` to be executed when the promise `p` is\n  rejected. Returns a promise that will be resolved with the return\n  value of calling `f` with exception as single argument; `f` can\n  return a plain value or promise instance, an automatic unwrapping\n  will be performed.\n\n  The computation will be executed in the completion thread, look at\n  `merr` if you want the ability to schedule the computation to other\n  thread.\"\n  ([p f]\n   (pt/-merr (pt/-promise p) #(pt/-promise (f %))))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-merr\n      (pt/-promise p)\n      (fn [e]\n        (if (accept? e)\n          (pt/-promise (f e))\n          (impl/rejected e)))))))\n\n(defn merr\n  \"Chains a function `f` to be executed when the promise `p` is\n  rejected. Returns a promise that will mirror the promise returned by\n  calling `f` with exception as single argument; `f` **must** return a\n  promise instance or throw an exception.\n\n  The computation will be executed in the completion thread by\n  default; you also can provide a custom executor.\n\n  This is intended to be used with `->>`.\"\n  ([f p] (pt/-merr p f))\n  ([executor f p] (pt/-merr p f executor)))\n\n(defn all\n  \"Given an array of promises, return a promise that is fulfilled when\n  all the items in the array are fulfilled.\n\n  Example:\n\n  ```\n  (-> (p/all [(promise :first-promise)\n              (promise :second-promise)])\n      (then (fn [[first-result second-result]])\n              (println (str first-result \\\", \\\" second-result))))\n  ```\n\n  Will print to out `:first-promise, :second-promise`.\n\n  If at least one of the promises is rejected, the resulting promise\n  will be rejected.\"\n  [promises]\n  (impl/all promises))\n\n(defn race\n  [promises]\n  (impl/race promises))\n\n(defn any\n  \"Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.\"\n  ([promises]\n   (any promises ::default))\n  ([promises default]\n   (c/let [items (into #{} promises)\n           state (volatile! {:pending items\n                             :rejections []\n                             :resolved? false})\n           lock  (util/mutex)]\n     (create\n      (fn [resolve reject]\n        (c/doseq [p promises]\n          (pt/-fnly\n           (pt/-promise p)\n           (fn [v exception]\n             (pt/-lock! lock)\n             (try\n               (if exception\n                 (when-not (:resolved? @state)\n                   (c/let [state (vswap! state (fn [state]\n                                                 (c/-> state\n                                                       (update :pending disj p)\n                                                       (update :rejections conj exception))))]\n                     (when-not (seq (:pending state))\n                       (if (= default ::default)\n                         (reject (ex-info \"No promises resolved\"\n                                          {:rejections (:rejections state)}))\n                         (resolve default)))))\n\n                 (when-not (:resolved? @state)\n                   (c/let [{:keys [pending]} (vswap! state (fn [state]\n                                                             (c/-> state\n                                                                   (assoc :resolved? true)\n                                                                   (update :pending disj p))))]\n                     #?(:clj (c/run! pt/-cancel! pending))\n                     (resolve v))))\n               (finally\n                 (pt/-unlock! lock)))))))))))\n\n(defn wait-all*\n  \"Given an array of promises, return a promise that is fulfilled when\n  all the items in the array are resolved (independently if\n  successfully or exceptionally).\n\n  Example:\n\n  ```\n  (->> (p/wait-all* [(promise :first-promise)\n                     (promise :second-promise)])\n       (p/fmap (fn [_]\n                 (println \\\"done\\\"))))\n  ```\n\n  Rejected promises also counts as resolved.\"\n  [promises]\n  (c/let [promises (set promises)\n          total    (count promises)\n          prom     (deferred)]\n    (if (pos? total)\n      (c/let [counter (atom total)]\n        (c/run! #(pt/-fnly % (fn [_ _]\n                               (when (= 0 (swap! counter dec))\n                                 (pt/-resolve! prom nil))))\n                promises))\n      (pt/-resolve! prom nil))\n    prom))\n\n(defn wait-all\n  \"Given a variable number of promises, returns a promise which resolves\n  to `nil` when all provided promises complete (rejected or resolved).\n\n  **EXPERIMENTAL**\"\n  [& promises]\n  (wait-all* (into #{} promises)))\n\n#?(:clj\n   (defn wait-all!\n     \"A blocking version of `wait-all`.\"\n     [promises]\n     (pt/-await! (wait-all promises))))\n\n(defn run!\n  \"A promise aware run! function. Executed in terms of `then` rules.\"\n  ([f coll]\n   (c/-> (c/reduce #(then %1 (fn [_] (f %2))) (impl/resolved nil) coll)\n         (pt/-fmap (constantly nil))))\n  ([f coll executor]\n   (c/-> (c/reduce #(then %1 (fn [_] (f %2)) executor) (impl/resolved nil) coll)\n         (pt/-fmap (constantly nil)))))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel! p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Completable\n\n(defn resolve!\n  \"Resolve a completable promise with a value.\"\n  ([o] (pt/-resolve! o nil))\n  ([o v] (pt/-resolve! o v)))\n\n(defn reject!\n  \"Reject a completable promise with an error.\"\n  [p e]\n  (pt/-reject! p e))\n\n;; --- Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument, return a\n  function that returns a promise. Callback is expected to take one\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (create (fn [resolve reject]\n               (c/let [args (c/-> (vec args) (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                     (reject e))))))))\n\n#?(:cljs\n   (defn ^{:jsdoc [\"@constructor\"]}\n     TimeoutException [message]\n     (this-as it\n       (.call js/Error it message {} nil)\n       it)))\n\n#?(:cljs\n   (goog/inherits TimeoutException js/Error))\n\n(defn timeout\n  \"Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError.\"\n  ([p t] (timeout p t ::default :default))\n  ([p t v] (timeout p t v :default))\n  ([p t v scheduler]\n   (c/let [timeout (deferred)\n           tid     (exec/schedule! scheduler t #(if (= v ::default)\n                                                  (reject! timeout (TimeoutException. \"Operation timed out.\"))\n                                                  (resolve! timeout v)))]\n     (race [(fnly (fn [_ _] (pt/-cancel! tid)) p) timeout]))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional value, returns a promise\n  that will be fulfilled with provided value (or nil) after the time is\n  reached.\"\n  ([t] (delay t nil :default))\n  ([t v] (delay t v :default))\n  ([t v scheduler]\n   (c/let [d (deferred)]\n     (exec/schedule! scheduler t #(resolve! d v))\n     d)))\n\n(defmacro do*\n  \"An exception unsafe do-like macro. Supposes that we are already\n  wrapped in promise context so avoids defensive wrapping.\"\n  [& exprs]\n  (condp = (count exprs)\n    0 `(impl/resolved nil)\n    1 `(pt/-promise ~(first exprs))\n    (reduce (fn [acc e]\n              `(pt/-mcat (pt/-promise ~e) (fn [_#] ~acc)))\n            `(pt/-promise ~(last exprs))\n            (reverse (butlast exprs)))))\n\n(defmacro do\n  \"Execute potentially side effectful code and return a promise resolved\n  to the last expression after awaiting the result of each\n  expression.\"\n  [& exprs]\n  `(pt/-mcat\n    (pt/-promise nil)\n    (fn [_#]\n      (promesa.core/do* ~@exprs))))\n\n(defmacro do!\n  \"A convenience alias for `do` macro.\"\n  [& exprs]\n  `(promesa.core/do ~@exprs))\n\n(defmacro let*\n  \"An exception unsafe let-like macro. Supposes that we are already\n  wrapped in promise context so avoids defensive wrapping.\"\n  [bindings & body]\n  (assert (even? (count bindings)) (str \"Uneven binding vector: \" bindings))\n  (c/->> (reverse (partition 2 bindings))\n         (reduce (fn [acc [l r]]\n                   `(pt/-mcat (pt/-promise ~r) (fn [~l] ~acc)))\n                 `(do* ~@body))))\n\n(defmacro let\n  \"A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.\"\n  [bindings & body]\n  (if (seq bindings)\n    `(pt/-mcat\n      (pt/-promise nil)\n      (fn [_#] (promesa.core/let* ~bindings ~@body)))\n    `(promesa.core/do ~@body)))\n\n(defmacro plet\n  \"A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.\"\n  [bindings & body]\n  (assert (even? (count bindings)) (str \"Uneven binding vector: \" bindings))\n  `(pt/-mcat\n    (pt/-promise nil)\n    (fn [_#]\n      ~(c/let [bindings (partition 2 bindings)]\n         `(c/-> (all ~(mapv second bindings))\n                (bind (fn [[~@(c/map first bindings)]]\n                        (promesa.core/do* ~@body))))))))\n\n(defn thread-call\n  \"Analogous to `clojure.core.async/thread` that returns a promise\n  instance instead of the `Future`. Useful for executing synchronous\n  code in a separate thread (also works in cljs).\"\n  ([f] (exec/submit! :thread (exec/wrap-bindings f)))\n  ([executor f] (exec/submit! executor (exec/wrap-bindings f))))\n\n(defn vthread-call\n  \"A shortcut for `(p/thread-call :vthread f)`.\"\n  [f]\n  (thread-call :vthread f))\n\n(defmacro thread\n  \"Analogous to `clojure.core.async/thread` that returns a promise instance\n  instead of the `Future`.\"\n  [& body]\n  `(thread-call (^once fn [] ~@body)))\n\n(defmacro vthread\n  \"Analogous to `clojure.core.async/thread` that returns a promise instance\n  instead of the `Future`. Useful for executing synchronous code in a\n  separate thread (also works in cljs).\"\n  [& body]\n  `(vthread-call (^once fn [] ~@body)))\n\n(defmacro future\n  \"Analogous macro to `clojure.core/future` that returns promise\n  instance instead of the `Future`. Exposed just for convenience and\n  works as an alias to `thread`.\"\n  [& body]\n  `(thread-call :default (^once fn [] ~@body)))\n\n(defrecord Recur [bindings])\n(defn recur?\n  [o]\n  (instance? Recur o))\n\n(defmacro loop\n  [bindings & body]\n  (c/let [binds (partition 2 2 bindings)\n          names (c/map first binds)\n          fvals (c/map second binds)\n          tsym  (gensym \"loop-fn-\")\n          res-s (gensym \"res-\")\n          err-s (gensym \"err-\")\n          rej-s (gensym \"reject-fn-\")\n          rsv-s (gensym \"resolve-fn-\")]\n    `(create\n      (fn [~rsv-s ~rej-s]\n        (c/let [~tsym (fn ~tsym [~@names]\n                        (c/->> (promesa.core/let [~@(c/mapcat (fn [nsym] [nsym nsym]) names)] ~@body)\n                               (promesa.core/fnly\n                                (fn [~res-s ~err-s]\n                                  ;; (prn \"result\" res# err#)\n                                  (if (some? ~err-s)\n                                    (~rej-s ~err-s)\n                                    (if (recur? ~res-s)\n                                      (do\n                                        (promesa.exec/run!\n                                         :vthread\n                                         (promesa.exec/wrap-bindings\n                                          ~(if (seq names)\n                                             `(fn [] (apply ~tsym (:bindings ~res-s)))\n                                           tsym)))\n                                      nil)\n                                      (~rsv-s ~res-s)))))))]\n          (promesa.exec/run!\n           :vthread\n           (promesa.exec/wrap-bindings\n            ~(if (seq names)\n               `(fn [] (~tsym ~@fvals))\n               tsym))))))))\n\n(defmacro recur\n  [& args]\n  `(->Recur [~@args]))\n\n(defmacro ->\n  \"Like the clojure.core/->, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise.\n\n  Example fetching data in the browser with CLJS:\n\n  (p/-> (js/fetch #js {...}) ; returns a promise\n        .-body)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.\"\n  [x & forms]\n  (c/let [fns (mapv (fn [arg]\n                      (c/let [[f & args] (if (sequential? arg)\n                                           arg\n                                           (list arg))]\n                        `(fn [p#] (~f p# ~@args)))) forms)]\n    `(chain (promise ~x) ~@fns)))\n\n(defmacro ->>\n  \"Like the clojure.core/->>, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise.\n\n  Example fetching data in the browser with CLJS:\n\n  (p/->> (js/fetch #js {...}) ; returns a promise\n         .-body\n         read-string\n         (mapv inc)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.\"\n  [x & forms]\n  (c/let [fns (mapv (fn [arg]\n                      (c/let [[f & args] (if (sequential? arg)\n                                           arg\n                                           (list arg))]\n                        `(fn [p#] (~f ~@args p#)))) forms)]\n    `(chain (promise ~x) ~@fns)))\n\n(defmacro as->\n  \"Like clojure.core/as->, but it will handle promises in values\n   and make sure the next form gets the value realized instead of\n   the promise.\"\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) (butlast forms))]\n     ~(if (empty? forms)\n        name\n        (last forms))))\n\n(defmacro with-redefs\n  \"Like clojure.core/with-redefs, but it will handle promises in\n   body and wait until they resolve or reject before restoring the\n   bindings. Useful for mocking async APIs.\"\n  [bindings & body]\n  (c/let [names         (take-nth 2 bindings)\n          vals          (take-nth 2 (drop 1 bindings))\n          orig-val-syms (c/map (comp gensym #(str % \"-orig-val__\") name) names)\n          temp-val-syms (c/map (comp gensym #(str % \"-temp-val__\") name) names)\n          binds         (c/map vector names temp-val-syms)\n          resets        (reverse (c/map vector names orig-val-syms))\n          bind-value    (if (:ns &env)\n                          (fn [[k v]] (list 'set! k v))\n                          (fn [[k v]] (list 'alter-var-root (list 'var k) (list 'constantly v))))]\n    `(c/let [~@(interleave orig-val-syms names)\n             ~@(interleave temp-val-syms vals)]\n       ~@(c/map bind-value binds)\n       (c/-> (promesa.core/do! ~@body)\n             (promesa.core/finally\n               (fn [_# _#]\n                 ~@(c/map bind-value resets)))))))\n\n(defmacro doseq\n  \"Simplified version of `doseq` which takes one binding and a seq, and\n  runs over it using `promesa.core/run!`\"\n  [[binding xs] & body]\n  `(run! (fn [~binding]\n           (promesa.core/do* ~@body))\n         ~xs))\n\n#?(:clj\n(defn await!\n  \"Generic await operation. Block current thread until some operation\n  terminates. Returns `nil` on timeout; does not catch any other\n  exception.\n\n  Default implementation for Thread, CompletableFuture and\n  CountDownLatch.\n\n  The return value is implementation specific.\"\n  ([resource]\n   (try\n     (pt/-await! resource)\n     (catch ExecutionException e\n       (throw (.getCause e)))\n     (catch CompletionException e\n       (throw (.getCause e)))))\n  ([resource duration]\n   (try\n     (pt/-await! resource duration)\n     (catch ExecutionException e\n       (throw (.getCause e)))\n     (catch CompletionException e\n       (throw (.getCause e)))\n     (catch TimeoutException _\n       nil)))))\n\n#?(:clj\n(defn await\n  \"A exception safer variant of `await!`. Returns `nil` on timeout\n  exception, forwards interrupted exception and all other exceptions\n  are returned as value, so user is responsible for checking if the returned\n  value is exception or not.\"\n  ([resource]\n   (try\n     (pt/-await! resource)\n     (catch ExecutionException e\n       (.getCause e))\n     (catch CompletionException e\n       (.getCause e))\n     (catch InterruptedException cause\n       (throw cause))\n     (catch Throwable cause\n       cause)))\n  ([resource duration]\n   (try\n     (pt/-await! resource duration)\n     (catch TimeoutException _\n       nil)\n     (catch ExecutionException e\n       (.getCause e))\n     (catch CompletionException e\n       (.getCause e))\n     (catch InterruptedException cause\n       (throw cause))\n     (catch Throwable cause\n       cause)))))\n"]}
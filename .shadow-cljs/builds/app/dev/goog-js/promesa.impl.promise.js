["^ ","~:resource-id",["~:shadow.build.classpath/resource","promesa/impl/promise.js"],"~:js","goog.provide(\"promesa.impl.promise\");\ngoog.provide(\"promesa.impl.promise.PromiseImpl\");\ngoog.provide(\"promesa.impl.promise.CancellationError\");\ngoog.scope(function() {\n  const self = promesa.impl.promise;\n  const root = goog.global;\n  const PENDING = Symbol(\"state/pending\");\n  const RESOLVED = Symbol(\"state/resolved\");\n  const REJECTED = Symbol(\"state/rejected\");\n  const QUEUE = Symbol(\"queue\");\n  const STATE = Symbol(\"state\");\n  const VALUE = Symbol(\"value\");\n  const RESOLVE_TYPE_FLATTEN = Symbol(\"resolve-type/flatten\");\n  const RESOLVE_TYPE_BIND = Symbol(\"resolve-type/bind\");\n  const RESOLVE_TYPE_MAP = Symbol(\"resolve-type/map\");\n  const defaultResolveMapHandler = v => {\n    return v;\n  };\n  const defaultResolveBindHandler = v => {\n    return self.resolved(v);\n  };\n  const defaultRejectHandler = c => {\n    throw c;\n  };\n  class CancellationError extends Error {\n  }\n  class PromiseImpl {\n    constructor(val) {\n      this[QUEUE] = [];\n      this[STATE] = PENDING;\n      this[VALUE] = undefined;\n      if (val !== undefined) {\n        transition(this, RESOLVED, val);\n      }\n    }\n    get state() {\n      return this[STATE];\n    }\n    get value() {\n      return this[VALUE];\n    }\n    then(resolve, reject) {\n      const deferred = new PromiseImpl();\n      let $jscomp$nullish$tmp0;\n      let $jscomp$nullish$tmp1;\n      this[QUEUE].push({type:RESOLVE_TYPE_FLATTEN, resolve:($jscomp$nullish$tmp0 = resolve) != null ? $jscomp$nullish$tmp0 : defaultResolveMapHandler, reject:($jscomp$nullish$tmp1 = reject) != null ? $jscomp$nullish$tmp1 : defaultRejectHandler, complete:completeDeferredFn(deferred)});\n      process(this);\n      return deferred;\n    }\n    catch(reject) {\n      return this.then(null, reject);\n    }\n    fmap(resolve, reject) {\n      const deferred = new PromiseImpl();\n      let $jscomp$nullish$tmp2;\n      let $jscomp$nullish$tmp3;\n      this[QUEUE].push({type:RESOLVE_TYPE_MAP, resolve:($jscomp$nullish$tmp2 = resolve) != null ? $jscomp$nullish$tmp2 : defaultResolveMapHandler, reject:($jscomp$nullish$tmp3 = reject) != null ? $jscomp$nullish$tmp3 : defaultRejectHandler, complete:completeDeferredFn(deferred)});\n      process(this);\n      return deferred;\n    }\n    fbind(resolve, reject) {\n      const deferred = new PromiseImpl();\n      let $jscomp$nullish$tmp4;\n      let $jscomp$nullish$tmp5;\n      this[QUEUE].push({type:RESOLVE_TYPE_BIND, resolve:($jscomp$nullish$tmp4 = resolve) != null ? $jscomp$nullish$tmp4 : defaultResolveBindHandler, reject:($jscomp$nullish$tmp5 = reject) != null ? $jscomp$nullish$tmp5 : defaultRejectHandler, complete:completeDeferredFn(deferred)});\n      process(this);\n      return deferred;\n    }\n    handle(fn, resolveType) {\n      let $jscomp$nullish$tmp6;\n      resolveType = ($jscomp$nullish$tmp6 = resolveType) != null ? $jscomp$nullish$tmp6 : RESOLVE_TYPE_MAP;\n      this[QUEUE].push({type:resolveType, resolve:defaultResolveMapHandler, reject:defaultRejectHandler, complete:fn});\n      process(this);\n    }\n    resolve(value) {\n      if (this[STATE] === PENDING) {\n        transition(this, RESOLVED, value);\n      }\n      return null;\n    }\n    reject(cause) {\n      if (this[STATE] === PENDING) {\n        transition(this, REJECTED, cause);\n      }\n      return null;\n    }\n    isPending() {\n      const state = this[STATE];\n      return state === PENDING;\n    }\n    isResolved() {\n      const state = this[STATE];\n      return state === RESOLVED;\n    }\n    isRejected() {\n      const state = this[STATE];\n      return state === REJECTED;\n    }\n    isCancelled() {\n      const state = this[STATE];\n      const value = this[VALUE];\n      return state === REJECTED && isCancellationError(value);\n    }\n    cancel() {\n      this.reject(new CancellationError(\"promise cancelled\"));\n    }\n  }\n  const nextTick = (() => {\n    if (typeof root.Promise === \"function\") {\n      const resolved = Promise.resolve(null);\n      return function queueMicrotaskWithPromise(f, p) {\n        resolved.then(() => {\n          return f(p);\n        });\n      };\n    } else {\n      if (typeof root.setImmediate === \"function\") {\n        return root.setImmediate;\n      } else {\n        if (typeof root.setTimeout === \"function\") {\n          return (f, p) => {\n            return root.setTimeout(f, 0, p);\n          };\n        } else {\n          return (f, p) => {\n            return f.call(this, p);\n          };\n        }\n      }\n    }\n  })();\n  function isCancellationError(v) {\n    return v instanceof CancellationError;\n  }\n  function fmtValue(o) {\n    if (isThenable(o)) {\n      return `<PROMISE:${goog.getUid(o)}>`;\n    } else {\n      if (o instanceof Error) {\n        return `<EXCEPTION:'${o.message}'>`;\n      } else {\n        if (o === null || o === undefined) {\n          return `${o}`;\n        } else {\n          if (typeof o === \"function\") {\n            return `<FN:${goog.getUid(o)}>`;\n          } else {\n            return `${o.toString()}`;\n          }\n        }\n      }\n    }\n  }\n  function isFunction(o) {\n    return typeof o === \"function\";\n  }\n  function isThenable(o) {\n    if (goog.isObject(o)) {\n      const thenFn = o.then;\n      return isFunction(thenFn);\n    } else {\n      return false;\n    }\n  }\n  function constantly(v) {\n    return () => {\n      return v;\n    };\n  }\n  function identity(v) {\n    return v;\n  }\n  function isPromiseImpl(v) {\n    return v instanceof PromiseImpl;\n  }\n  function completeDeferredFn(deferred) {\n    return (value, cause) => {\n      if (cause) {\n        deferred.reject(cause);\n      } else {\n        deferred.resolve(value);\n      }\n    };\n  }\n  function process(p) {\n    if (p[STATE] === PENDING) {\n      return;\n    }\n    nextTick(processNextTick, p);\n    return p;\n  }\n  function processNextTick(p) {\n    if (p[QUEUE].length === 0) {\n      return;\n    }\n    const state = p[STATE];\n    const value = p[VALUE];\n    let task, rvalue, rcause;\n    while (p[QUEUE].length) {\n      task = p[QUEUE].shift();\n      try {\n        if (state === RESOLVED) {\n          rvalue = task.resolve(value);\n        } else {\n          if (state === REJECTED) {\n            rvalue = task.reject(value);\n          } else {\n            rcause = new TypeError(\"invalid state\");\n          }\n        }\n      } catch (e) {\n        rcause = e;\n      }\n      resolveTask(task, rvalue, rcause);\n    }\n  }\n  function resolveTask(task, value, cause) {\n    if (cause) {\n      task.complete(null, cause);\n    } else {\n      if (task.type === RESOLVE_TYPE_MAP) {\n        task.complete(value, null);\n      } else {\n        if (task.type === RESOLVE_TYPE_FLATTEN) {\n          if (isPromiseImpl(value)) {\n            value.handle((v, c) => {\n              resolveTask(task, v, c);\n            });\n          } else {\n            if (isThenable(value)) {\n              value.then(v => {\n                resolveTask(task, v, null);\n              }, c => {\n                resolveTask(task, null, c);\n              });\n            } else {\n              task.complete(value, null);\n            }\n          }\n        } else {\n          if (task.type === RESOLVE_TYPE_BIND) {\n            if (isPromiseImpl(value)) {\n              value.handle((v, c) => {\n                task.complete(v, c);\n              });\n            } else {\n              if (isThenable(value)) {\n                value.then(v => {\n                  task.complete(v, null);\n                }, c => {\n                  task.complete(null, c);\n                });\n              } else {\n                task.complete(null, new TypeError(\"expected thenable\"));\n              }\n            }\n          } else {\n            task.complete(null, new TypeError(\"internal: invalid resolve type\"));\n          }\n        }\n      }\n    }\n  }\n  function transition(p, state, value) {\n    if (p[STATE] === state || p[STATE] !== PENDING) {\n      return;\n    }\n    p[STATE] = state;\n    p[VALUE] = value;\n    return processNextTick(p);\n  }\n  self.PromiseImpl = PromiseImpl;\n  self.CancellationError = CancellationError;\n  self.isCancellationError = isCancellationError;\n  self.deferred = () => {\n    return new PromiseImpl();\n  };\n  const NULL_PROMISE = new PromiseImpl(null);\n  self.resolved = function resolved(value) {\n    if (value === null) {\n      return NULL_PROMISE;\n    } else {\n      const p = new PromiseImpl();\n      p[STATE] = RESOLVED;\n      p[VALUE] = value;\n      return p;\n    }\n  };\n  self.rejected = function rejected(reason) {\n    const p = new PromiseImpl();\n    p[STATE] = REJECTED;\n    p[VALUE] = reason;\n    return p;\n  };\n  self.all = function all(promises) {\n    return promises.reduce(function(acc, p) {\n      return acc.then(results => {\n        return self.coerce(p).fmap(v => {\n          results.push(v);\n          return results;\n        });\n      });\n    }, self.resolved([]));\n  };\n  self.coerce = function coerce(promise) {\n    if (promise instanceof PromiseImpl) {\n      return promise;\n    } else {\n      const deferred = self.deferred();\n      promise.then(v => {\n        deferred.resolve(v);\n      }, c => {\n        deferred.reject(c);\n      });\n      return deferred;\n    }\n  };\n  self.race = function race(promises) {\n    const deferred = self.deferred();\n    promises.forEach(p => {\n      self.coerce(p).handle((v, c) => {\n        if (c) {\n          deferred.reject(c);\n        } else {\n          deferred.resolve(v);\n        }\n      });\n    });\n    return deferred;\n  };\n  self.nextTick = nextTick;\n  self.PENDING = PENDING;\n  self.RESOLVED = RESOLVED;\n  self.REJECTED = REJECTED;\n});\n","~:source","\"use strict\";\n\ngoog.provide(\"promesa.impl.promise\");\ngoog.provide(\"promesa.impl.promise.PromiseImpl\");\ngoog.provide(\"promesa.impl.promise.CancellationError\");\n\ngoog.scope(function() {\n  const self = promesa.impl.promise;\n  const root = goog.global;\n\n  const PENDING = Symbol(\"state/pending\");\n  const RESOLVED = Symbol(\"state/resolved\");\n  const REJECTED = Symbol(\"state/rejected\");\n\n  const QUEUE = Symbol(\"queue\");\n  const STATE = Symbol(\"state\");\n  const VALUE = Symbol(\"value\");\n\n  const RESOLVE_TYPE_FLATTEN = Symbol(\"resolve-type/flatten\");\n  const RESOLVE_TYPE_BIND = Symbol(\"resolve-type/bind\");\n  const RESOLVE_TYPE_MAP = Symbol(\"resolve-type/map\");\n\n  const defaultResolveMapHandler = (v) => v;\n  const defaultResolveBindHandler = (v) => self.resolved(v);\n  const defaultRejectHandler = (c) => {throw c;};\n\n  class CancellationError extends Error {}\n\n  class PromiseImpl {\n    constructor (val) {\n      this[QUEUE] = [];\n      this[STATE] = PENDING;\n      this[VALUE] = undefined;\n\n      if (val !== undefined) {\n        transition(this, RESOLVED, val);\n      }\n    }\n\n    get state () {\n      return this[STATE];\n    }\n\n    get value () {\n      return this[VALUE];\n    }\n\n    then (resolve, reject) {\n      const deferred = new PromiseImpl();\n\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_FLATTEN,\n        resolve: resolve ?? defaultResolveMapHandler,\n        reject: reject ?? defaultRejectHandler,\n        complete: completeDeferredFn(deferred)\n      });\n\n      // console.log(\"then\",\n      //             \"uid:\", goog.getUid(this),\n      //             \"return-uid:\", goog.getUid(deferred),\n      //             \"state:\", this[STATE],\n      //             \"value:\", fmtValue(this[VALUE]));\n\n      process(this);\n      return deferred;\n    }\n\n    catch (reject) {\n      return this.then(null, reject);\n    }\n\n    fmap (resolve, reject) {\n      const deferred = new PromiseImpl();\n\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_MAP,\n        resolve: resolve ?? defaultResolveMapHandler,\n        reject: reject ?? defaultRejectHandler,\n        complete: completeDeferredFn(deferred)\n      });\n\n      // console.log(\"fmap\",\n      //             \"uid:\", goog.getUid(this),\n      //             \"return-uid:\", goog.getUid(deferred),\n      //             \"state:\", this[STATE],\n      //             \"value:\", fmtValue(this[VALUE]));\n\n      process(this);\n      return deferred;\n    }\n\n    fbind (resolve, reject) {\n      const deferred = new PromiseImpl();\n\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_BIND,\n        resolve: resolve ?? defaultResolveBindHandler,\n        reject: reject ?? defaultRejectHandler,\n        complete: completeDeferredFn(deferred)\n      });\n\n      // console.log(\"fbind\",\n      //             \"uid:\", goog.getUid(this),\n      //             \"return-uid:\", goog.getUid(deferred),\n      //             \"state:\", this[STATE],\n      //             \"value:\", fmtValue(this[VALUE]));\n\n      process(this);\n      return deferred;\n    }\n\n    handle (fn, resolveType) {\n      resolveType = resolveType ?? RESOLVE_TYPE_MAP;\n\n      this[QUEUE].push({\n        type: resolveType,\n        resolve: defaultResolveMapHandler,\n        reject: defaultRejectHandler,\n        complete: fn\n      });\n\n      process(this);\n    }\n\n    // Deferred Methods\n\n    resolve(value) {\n      if (this[STATE] === PENDING) {\n        // console.log(\":: [deferred:resolve]\",\n        //             \"uid:\", goog.getUid(this),\n        //             \"value:\", fmtValue(value));\n\n        transition(this, RESOLVED, value);\n      }\n      return null;\n    }\n\n    reject(cause) {\n      if (this[STATE] === PENDING) {\n        // console.log(\":: [deferred:reject]\",\n        //             \"uid:\", goog.getUid(this),\n        //             \"value:\", fmtValue(cause));\n        transition(this, REJECTED, cause);\n      }\n      return null;\n    }\n\n    isPending() {\n      const state = this[STATE];\n      return state === PENDING;\n    }\n\n    isResolved() {\n      const state = this[STATE];\n      return state === RESOLVED;\n    }\n\n\n    isRejected() {\n      const state = this[STATE];\n      return state === REJECTED;\n    }\n\n    isCancelled() {\n      const state = this[STATE];\n      const value = this[VALUE];\n      return (state === REJECTED && isCancellationError(value));\n    }\n\n    cancel() {\n      this.reject(new CancellationError(\"promise cancelled\"));\n    }\n  }\n\n  const nextTick = (() => {\n    if (typeof root.Promise === \"function\") {\n      const resolved = Promise.resolve(null);\n      return function queueMicrotaskWithPromise(f, p) {\n        resolved.then(() => f(p));\n      };\n    } else if (typeof root.setImmediate === \"function\") {\n      return root.setImmediate;\n    } else if (typeof root.setTimeout === \"function\") {\n      return (f, p) => root.setTimeout(f, 0, p);\n    } else {\n      // console.error(\"No nextTick. How we gonna do this?\");\n      return (f, p) => f.call(this, p);\n    }\n  })();\n\n  function isCancellationError(v) {\n    return v instanceof CancellationError;\n  }\n\n  function fmtValue (o) {\n    if (isThenable(o)) {\n      return `<PROMISE:${goog.getUid(o)}>`;\n    } else if (o instanceof Error) {\n      return `<EXCEPTION:'${o.message}'>`;\n    } else if (o === null || o === undefined) {\n      return `${o}`;\n    } else if (typeof o === \"function\") {\n      return `<FN:${goog.getUid(o)}>`;\n    } else {\n      return `${o.toString()}`;\n    }\n  }\n\n  function isFunction (o) {\n    return typeof o === \"function\";\n  }\n\n  function isThenable (o) {\n    if (goog.isObject(o)) {\n      const thenFn = o.then;\n      return isFunction(thenFn);\n    } else {\n      return false;\n    }\n  }\n\n  function constantly(v) {\n    return () => v;\n  }\n\n  function identity (v) {\n    return v;\n  }\n\n  function isPromiseImpl (v) {\n    return v instanceof PromiseImpl;\n  }\n\n  function completeDeferredFn(deferred) {\n    return (value, cause) => {\n      if (cause) {\n        deferred.reject(cause);\n      } else {\n        deferred.resolve(value);\n      }\n    };\n  }\n\n  function process(p) {\n    if (p[STATE] === PENDING) return;\n    nextTick(processNextTick, p);\n    return p;\n  }\n\n  function processNextTick(p) {\n    if (p[QUEUE].length === 0) return;\n\n    const state = p[STATE];\n    const value = p[VALUE];\n    let task, rvalue, rcause;\n\n    // console.log(\":: process:\",\n    //             \"uid:\", goog.getUid(p),\n    //             \"queue size:\", p[QUEUE].length,\n    //             \"state:\", p[STATE],\n    //             \"value:\", fmtValue(p[VALUE]));\n\n    while (p[QUEUE].length) {\n      task = p[QUEUE].shift();\n\n      // console.log(\":: process-task:\",\n      //             \"deferred-uid:\", task.deferred ? goog.getUid(task.deferred) : null,\n      //             \"type:\", task.type);\n\n      try {\n        if (state === RESOLVED) {\n          rvalue = task.resolve(value)\n        } else if (state === REJECTED) {\n          rvalue = task.reject(value)\n        } else {\n          rcause = new TypeError(\"invalid state\");\n        }\n      } catch (e) {\n        rcause = e;\n      }\n\n      resolveTask(task, rvalue, rcause);\n    }\n  }\n\n\n  function resolveTask(task, value, cause) {\n    if (cause) {\n      task.complete(null, cause);\n    } else {\n      if (task.type === RESOLVE_TYPE_MAP) {\n        // console.trace(task);\n        task.complete(value, null);\n      } else if (task.type === RESOLVE_TYPE_FLATTEN) {\n        if (isPromiseImpl(value)) {\n          value.handle((v, c) => {\n            resolveTask(task, v, c);\n          });\n        } else if (isThenable(value)) {\n          value.then((v) => {\n            resolveTask(task, v, null);\n          }, (c) => {\n            resolveTask(task, null, c);\n          });\n        } else {\n          task.complete(value, null);\n        }\n      } else if (task.type === RESOLVE_TYPE_BIND) {\n        if (isPromiseImpl(value)) {\n          value.handle((v, c) => {\n            task.complete(v, c);\n          });\n        } else if (isThenable(value)) {\n          value.then((v) => {\n            task.complete(v, null);\n          }, (c) => {\n            task.complete(null, c);\n          });\n        } else {\n          task.complete(null, new TypeError(\"expected thenable\"));\n        }\n      } else {\n        task.complete(null, new TypeError(\"internal: invalid resolve type\"));\n      }\n    }\n  }\n\n  function transition(p, state, value) {\n    // console.log(\">> transition\",\n    //             \"uid:\", goog.getUid(p),\n    //             \"from-state:\", p[STATE],\n    //             \"to-state:\", state,\n    //             \"value:\", fmtValue(value),\n    //             \"queue:\", p[QUEUE].length);\n\n    if (p[STATE] === state ||\n        p[STATE] !== PENDING) {\n      return;\n    }\n\n    p[STATE] = state;\n    p[VALUE] = value;\n\n    return processNextTick(p);\n  }\n\n  self.PromiseImpl = PromiseImpl;\n  self.CancellationError = CancellationError;\n  self.isCancellationError = isCancellationError;\n\n  self.deferred = () => {\n    return new PromiseImpl();\n  };\n\n  const NULL_PROMISE = new PromiseImpl(null);\n\n  self.resolved = function resolved (value) {\n    if (value === null) {\n      return NULL_PROMISE;\n    } else {\n      const p = new PromiseImpl();\n      p[STATE] = RESOLVED;\n      p[VALUE] = value;\n      // console.log(\"++ [resolved]\", \"uid:\", goog.getUid(p), \"value:\", value);\n\n      return p;\n    }\n  };\n\n  self.rejected = function rejected (reason) {\n    const p = new PromiseImpl();\n    p[STATE] = REJECTED;\n    p[VALUE] = reason;\n\n    // console.log(\"++ [rejected]\", \"uid:\", goog.getUid(p), \"value:\", fmtValue(reason));\n\n    return p;\n  };\n\n  self.all = function all (promises) {\n    return promises.reduce(function (acc, p) {\n      return acc.then((results) => {\n        return self.coerce(p).fmap((v) => {\n          results.push(v);\n          return results;\n        });\n      });\n    }, self.resolved([]));\n  };\n\n  self.coerce = function coerce (promise) {\n    if (promise instanceof PromiseImpl) {\n      return promise;\n    } else {\n      const deferred = self.deferred();\n      promise.then((v) => {\n        deferred.resolve(v);\n      }, (c) => {\n        deferred.reject(c);\n      });\n      return deferred;\n    }\n  };\n\n  self.race = function race (promises) {\n    const deferred = self.deferred();\n\n    promises.forEach((p) => {\n      self.coerce(p).handle((v, c) => {\n        if (c) {\n          deferred.reject(c);\n        } else {\n          deferred.resolve(v);\n        }\n      });\n    });\n\n    return deferred;\n  };\n\n  self.nextTick = nextTick;\n\n  self.PENDING = PENDING;\n  self.RESOLVED = RESOLVED;\n  self.REJECTED = REJECTED;\n});\n","~:compiled-at",1685728257347,"~:source-map-json","{\n\"version\":3,\n\"file\":\"promesa.impl.promise.js\",\n\"lineCount\":336,\n\"mappings\":\"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\",\n\"sources\":[\"promesa/impl/promise.js\"],\n\"sourcesContent\":[\"\\\"use strict\\\";\\n\\ngoog.provide(\\\"promesa.impl.promise\\\");\\ngoog.provide(\\\"promesa.impl.promise.PromiseImpl\\\");\\ngoog.provide(\\\"promesa.impl.promise.CancellationError\\\");\\n\\ngoog.scope(function() {\\n  const self = promesa.impl.promise;\\n  const root = goog.global;\\n\\n  const PENDING = Symbol(\\\"state/pending\\\");\\n  const RESOLVED = Symbol(\\\"state/resolved\\\");\\n  const REJECTED = Symbol(\\\"state/rejected\\\");\\n\\n  const QUEUE = Symbol(\\\"queue\\\");\\n  const STATE = Symbol(\\\"state\\\");\\n  const VALUE = Symbol(\\\"value\\\");\\n\\n  const RESOLVE_TYPE_FLATTEN = Symbol(\\\"resolve-type/flatten\\\");\\n  const RESOLVE_TYPE_BIND = Symbol(\\\"resolve-type/bind\\\");\\n  const RESOLVE_TYPE_MAP = Symbol(\\\"resolve-type/map\\\");\\n\\n  const defaultResolveMapHandler = (v) => v;\\n  const defaultResolveBindHandler = (v) => self.resolved(v);\\n  const defaultRejectHandler = (c) => {throw c;};\\n\\n  class CancellationError extends Error {}\\n\\n  class PromiseImpl {\\n    constructor (val) {\\n      this[QUEUE] = [];\\n      this[STATE] = PENDING;\\n      this[VALUE] = undefined;\\n\\n      if (val !== undefined) {\\n        transition(this, RESOLVED, val);\\n      }\\n    }\\n\\n    get state () {\\n      return this[STATE];\\n    }\\n\\n    get value () {\\n      return this[VALUE];\\n    }\\n\\n    then (resolve, reject) {\\n      const deferred = new PromiseImpl();\\n\\n      this[QUEUE].push({\\n        type: RESOLVE_TYPE_FLATTEN,\\n        resolve: resolve ?? defaultResolveMapHandler,\\n        reject: reject ?? defaultRejectHandler,\\n        complete: completeDeferredFn(deferred)\\n      });\\n\\n      // console.log(\\\"then\\\",\\n      //             \\\"uid:\\\", goog.getUid(this),\\n      //             \\\"return-uid:\\\", goog.getUid(deferred),\\n      //             \\\"state:\\\", this[STATE],\\n      //             \\\"value:\\\", fmtValue(this[VALUE]));\\n\\n      process(this);\\n      return deferred;\\n    }\\n\\n    catch (reject) {\\n      return this.then(null, reject);\\n    }\\n\\n    fmap (resolve, reject) {\\n      const deferred = new PromiseImpl();\\n\\n      this[QUEUE].push({\\n        type: RESOLVE_TYPE_MAP,\\n        resolve: resolve ?? defaultResolveMapHandler,\\n        reject: reject ?? defaultRejectHandler,\\n        complete: completeDeferredFn(deferred)\\n      });\\n\\n      // console.log(\\\"fmap\\\",\\n      //             \\\"uid:\\\", goog.getUid(this),\\n      //             \\\"return-uid:\\\", goog.getUid(deferred),\\n      //             \\\"state:\\\", this[STATE],\\n      //             \\\"value:\\\", fmtValue(this[VALUE]));\\n\\n      process(this);\\n      return deferred;\\n    }\\n\\n    fbind (resolve, reject) {\\n      const deferred = new PromiseImpl();\\n\\n      this[QUEUE].push({\\n        type: RESOLVE_TYPE_BIND,\\n        resolve: resolve ?? defaultResolveBindHandler,\\n        reject: reject ?? defaultRejectHandler,\\n        complete: completeDeferredFn(deferred)\\n      });\\n\\n      // console.log(\\\"fbind\\\",\\n      //             \\\"uid:\\\", goog.getUid(this),\\n      //             \\\"return-uid:\\\", goog.getUid(deferred),\\n      //             \\\"state:\\\", this[STATE],\\n      //             \\\"value:\\\", fmtValue(this[VALUE]));\\n\\n      process(this);\\n      return deferred;\\n    }\\n\\n    handle (fn, resolveType) {\\n      resolveType = resolveType ?? RESOLVE_TYPE_MAP;\\n\\n      this[QUEUE].push({\\n        type: resolveType,\\n        resolve: defaultResolveMapHandler,\\n        reject: defaultRejectHandler,\\n        complete: fn\\n      });\\n\\n      process(this);\\n    }\\n\\n    // Deferred Methods\\n\\n    resolve(value) {\\n      if (this[STATE] === PENDING) {\\n        // console.log(\\\":: [deferred:resolve]\\\",\\n        //             \\\"uid:\\\", goog.getUid(this),\\n        //             \\\"value:\\\", fmtValue(value));\\n\\n        transition(this, RESOLVED, value);\\n      }\\n      return null;\\n    }\\n\\n    reject(cause) {\\n      if (this[STATE] === PENDING) {\\n        // console.log(\\\":: [deferred:reject]\\\",\\n        //             \\\"uid:\\\", goog.getUid(this),\\n        //             \\\"value:\\\", fmtValue(cause));\\n        transition(this, REJECTED, cause);\\n      }\\n      return null;\\n    }\\n\\n    isPending() {\\n      const state = this[STATE];\\n      return state === PENDING;\\n    }\\n\\n    isResolved() {\\n      const state = this[STATE];\\n      return state === RESOLVED;\\n    }\\n\\n\\n    isRejected() {\\n      const state = this[STATE];\\n      return state === REJECTED;\\n    }\\n\\n    isCancelled() {\\n      const state = this[STATE];\\n      const value = this[VALUE];\\n      return (state === REJECTED && isCancellationError(value));\\n    }\\n\\n    cancel() {\\n      this.reject(new CancellationError(\\\"promise cancelled\\\"));\\n    }\\n  }\\n\\n  const nextTick = (() => {\\n    if (typeof root.Promise === \\\"function\\\") {\\n      const resolved = Promise.resolve(null);\\n      return function queueMicrotaskWithPromise(f, p) {\\n        resolved.then(() => f(p));\\n      };\\n    } else if (typeof root.setImmediate === \\\"function\\\") {\\n      return root.setImmediate;\\n    } else if (typeof root.setTimeout === \\\"function\\\") {\\n      return (f, p) => root.setTimeout(f, 0, p);\\n    } else {\\n      // console.error(\\\"No nextTick. How we gonna do this?\\\");\\n      return (f, p) => f.call(this, p);\\n    }\\n  })();\\n\\n  function isCancellationError(v) {\\n    return v instanceof CancellationError;\\n  }\\n\\n  function fmtValue (o) {\\n    if (isThenable(o)) {\\n      return `<PROMISE:${goog.getUid(o)}>`;\\n    } else if (o instanceof Error) {\\n      return `<EXCEPTION:'${o.message}'>`;\\n    } else if (o === null || o === undefined) {\\n      return `${o}`;\\n    } else if (typeof o === \\\"function\\\") {\\n      return `<FN:${goog.getUid(o)}>`;\\n    } else {\\n      return `${o.toString()}`;\\n    }\\n  }\\n\\n  function isFunction (o) {\\n    return typeof o === \\\"function\\\";\\n  }\\n\\n  function isThenable (o) {\\n    if (goog.isObject(o)) {\\n      const thenFn = o.then;\\n      return isFunction(thenFn);\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function constantly(v) {\\n    return () => v;\\n  }\\n\\n  function identity (v) {\\n    return v;\\n  }\\n\\n  function isPromiseImpl (v) {\\n    return v instanceof PromiseImpl;\\n  }\\n\\n  function completeDeferredFn(deferred) {\\n    return (value, cause) => {\\n      if (cause) {\\n        deferred.reject(cause);\\n      } else {\\n        deferred.resolve(value);\\n      }\\n    };\\n  }\\n\\n  function process(p) {\\n    if (p[STATE] === PENDING) return;\\n    nextTick(processNextTick, p);\\n    return p;\\n  }\\n\\n  function processNextTick(p) {\\n    if (p[QUEUE].length === 0) return;\\n\\n    const state = p[STATE];\\n    const value = p[VALUE];\\n    let task, rvalue, rcause;\\n\\n    // console.log(\\\":: process:\\\",\\n    //             \\\"uid:\\\", goog.getUid(p),\\n    //             \\\"queue size:\\\", p[QUEUE].length,\\n    //             \\\"state:\\\", p[STATE],\\n    //             \\\"value:\\\", fmtValue(p[VALUE]));\\n\\n    while (p[QUEUE].length) {\\n      task = p[QUEUE].shift();\\n\\n      // console.log(\\\":: process-task:\\\",\\n      //             \\\"deferred-uid:\\\", task.deferred ? goog.getUid(task.deferred) : null,\\n      //             \\\"type:\\\", task.type);\\n\\n      try {\\n        if (state === RESOLVED) {\\n          rvalue = task.resolve(value)\\n        } else if (state === REJECTED) {\\n          rvalue = task.reject(value)\\n        } else {\\n          rcause = new TypeError(\\\"invalid state\\\");\\n        }\\n      } catch (e) {\\n        rcause = e;\\n      }\\n\\n      resolveTask(task, rvalue, rcause);\\n    }\\n  }\\n\\n\\n  function resolveTask(task, value, cause) {\\n    if (cause) {\\n      task.complete(null, cause);\\n    } else {\\n      if (task.type === RESOLVE_TYPE_MAP) {\\n        // console.trace(task);\\n        task.complete(value, null);\\n      } else if (task.type === RESOLVE_TYPE_FLATTEN) {\\n        if (isPromiseImpl(value)) {\\n          value.handle((v, c) => {\\n            resolveTask(task, v, c);\\n          });\\n        } else if (isThenable(value)) {\\n          value.then((v) => {\\n            resolveTask(task, v, null);\\n          }, (c) => {\\n            resolveTask(task, null, c);\\n          });\\n        } else {\\n          task.complete(value, null);\\n        }\\n      } else if (task.type === RESOLVE_TYPE_BIND) {\\n        if (isPromiseImpl(value)) {\\n          value.handle((v, c) => {\\n            task.complete(v, c);\\n          });\\n        } else if (isThenable(value)) {\\n          value.then((v) => {\\n            task.complete(v, null);\\n          }, (c) => {\\n            task.complete(null, c);\\n          });\\n        } else {\\n          task.complete(null, new TypeError(\\\"expected thenable\\\"));\\n        }\\n      } else {\\n        task.complete(null, new TypeError(\\\"internal: invalid resolve type\\\"));\\n      }\\n    }\\n  }\\n\\n  function transition(p, state, value) {\\n    // console.log(\\\">> transition\\\",\\n    //             \\\"uid:\\\", goog.getUid(p),\\n    //             \\\"from-state:\\\", p[STATE],\\n    //             \\\"to-state:\\\", state,\\n    //             \\\"value:\\\", fmtValue(value),\\n    //             \\\"queue:\\\", p[QUEUE].length);\\n\\n    if (p[STATE] === state ||\\n        p[STATE] !== PENDING) {\\n      return;\\n    }\\n\\n    p[STATE] = state;\\n    p[VALUE] = value;\\n\\n    return processNextTick(p);\\n  }\\n\\n  self.PromiseImpl = PromiseImpl;\\n  self.CancellationError = CancellationError;\\n  self.isCancellationError = isCancellationError;\\n\\n  self.deferred = () => {\\n    return new PromiseImpl();\\n  };\\n\\n  const NULL_PROMISE = new PromiseImpl(null);\\n\\n  self.resolved = function resolved (value) {\\n    if (value === null) {\\n      return NULL_PROMISE;\\n    } else {\\n      const p = new PromiseImpl();\\n      p[STATE] = RESOLVED;\\n      p[VALUE] = value;\\n      // console.log(\\\"++ [resolved]\\\", \\\"uid:\\\", goog.getUid(p), \\\"value:\\\", value);\\n\\n      return p;\\n    }\\n  };\\n\\n  self.rejected = function rejected (reason) {\\n    const p = new PromiseImpl();\\n    p[STATE] = REJECTED;\\n    p[VALUE] = reason;\\n\\n    // console.log(\\\"++ [rejected]\\\", \\\"uid:\\\", goog.getUid(p), \\\"value:\\\", fmtValue(reason));\\n\\n    return p;\\n  };\\n\\n  self.all = function all (promises) {\\n    return promises.reduce(function (acc, p) {\\n      return acc.then((results) => {\\n        return self.coerce(p).fmap((v) => {\\n          results.push(v);\\n          return results;\\n        });\\n      });\\n    }, self.resolved([]));\\n  };\\n\\n  self.coerce = function coerce (promise) {\\n    if (promise instanceof PromiseImpl) {\\n      return promise;\\n    } else {\\n      const deferred = self.deferred();\\n      promise.then((v) => {\\n        deferred.resolve(v);\\n      }, (c) => {\\n        deferred.reject(c);\\n      });\\n      return deferred;\\n    }\\n  };\\n\\n  self.race = function race (promises) {\\n    const deferred = self.deferred();\\n\\n    promises.forEach((p) => {\\n      self.coerce(p).handle((v, c) => {\\n        if (c) {\\n          deferred.reject(c);\\n        } else {\\n          deferred.resolve(v);\\n        }\\n      });\\n    });\\n\\n    return deferred;\\n  };\\n\\n  self.nextTick = nextTick;\\n\\n  self.PENDING = PENDING;\\n  self.RESOLVED = RESOLVED;\\n  self.REJECTED = REJECTED;\\n});\\n\"],\n\"names\":[\"goog\",\"provide\",\"scope\",\"self\",\"promesa\",\"impl\",\"promise\",\"root\",\"global\",\"PENDING\",\"Symbol\",\"RESOLVED\",\"REJECTED\",\"QUEUE\",\"STATE\",\"VALUE\",\"RESOLVE_TYPE_FLATTEN\",\"RESOLVE_TYPE_BIND\",\"RESOLVE_TYPE_MAP\",\"defaultResolveMapHandler\",\"v\",\"defaultResolveBindHandler\",\"resolved\",\"defaultRejectHandler\",\"c\",\"CancellationError\",\"Error\",\"PromiseImpl\",\"constructor\",\"val\",\"undefined\",\"transition\",\"then\",\"resolve\",\"reject\",\"deferred\",\"push\",\"type\",\"complete\",\"completeDeferredFn\",\"process\",\"catch\",\"fmap\",\"fbind\",\"handle\",\"fn\",\"resolveType\",\"value\",\"cause\",\"isPending\",\"state\",\"isResolved\",\"isRejected\",\"isCancelled\",\"isCancellationError\",\"cancel\",\"nextTick\",\"Promise\",\"queueMicrotaskWithPromise\",\"f\",\"p\",\"setImmediate\",\"setTimeout\",\"call\",\"fmtValue\",\"o\",\"isThenable\",\"getUid\",\"message\",\"toString\",\"isFunction\",\"isObject\",\"thenFn\",\"constantly\",\"identity\",\"isPromiseImpl\",\"processNextTick\",\"length\",\"task\",\"rvalue\",\"rcause\",\"shift\",\"TypeError\",\"e\",\"resolveTask\",\"self.deferred\",\"NULL_PROMISE\",\"self.resolved\",\"rejected\",\"self.rejected\",\"reason\",\"all\",\"self.all\",\"promises\",\"reduce\",\"acc\",\"results\",\"coerce\",\"self.coerce\",\"race\",\"self.race\",\"forEach\"]\n}\n"]